#!/usr/bin/env ruby

require 'fcntl'
require 'loggability'
require 'configurability'
require 'trollop'

require 'laika' unless defined?( LAIKA )
require 'laika/mixins'
require 'laika/groundcontrol/worker'
require 'laika/groundcontrol/queue'

LAIKA.require_features( :groundcontrol )


# The GroundControl worker daemon. Watches a GroundControl job queue, and runs the tasks
# contained in the jobs it fetches.
class LAIKA::GroundControl::WorkerDaemon
	extend Loggability,
		   LAIKA::MethodUtilities


	# Loggability API -- log to LAIKA's logger
	log_to :laika


	# VCS revision
	REVISION = %q$Revision: 1040717e8a22 $

	# The maximum number of children to have running at any given time
	DEFAULT_CREW_SIZE = 5

	# Signals we understand
	QUEUE_SIGS = [
		:QUIT, :INT, :TERM, :HUP,
		# :TODO: :WINCH, :USR1, :USR2, :TTIN, :TTOU
	]



	#
	# Class methods
	#

	### Get the daemon's version as a String.
	def self::version_string( include_buildnum=false )
		vstring = "%s %s" % [ self.name, LAIKA::GroundControl::VERSION ]
		vstring << " (build %s)" % [ REVISION[/: ([[:xdigit:]]+)/, 1] || '0' ] if include_buildnum
		return vstring
	end


	### Start the daemon.
	def self::run( argv )
		Loggability.format_with( :color ) if $stdout.tty?

		progname = File.basename( $0 )
		opts = Trollop.options do
			banner "Usage: #{progname} OPTIONS"
			version LAIKA::GroundControl::WorkerDaemon.version_string( true )

			opt :config, "The config file to load instead of the default",
				:type => :string
			opt :crew_size, "Number of workers to maintain.", :default => DEFAULT_CREW_SIZE
			opt :queue, "The name of the queue to monitor.", :default => '_default_'
			opt :features, "A list of LAIKA features to load",
				:type => :strings

			opt :debug, "Turn on debugging output."
		end

		# Turn on debugging if it's enabled
		if opts.debug
			$DEBUG = true
			Loggability.level = :debug
		end

		# Handle feature-loading
		self.load_features( opts.features ) if opts.features

		# Now load the config file
		LAIKA.load_config( argv.shift )

		# Re-enable debug-level logging if the config reset it
		Loggability.level = :debug if opts.debug

		# And start the daemon
		self.new( opts ).run
	end


	### Load any requested features.
	def self::load_features( features )

		# Handle comma-delimited features by splitting them out into the array
		features = features.collect do |feature|
			if feature.include?( ',' )
				feature.split( /\s*,\s*/ )
			else
				feature
			end
		end.flatten.compact

		features.each do |feature|
			LAIKA.require_features( feature )
		end
		
	end


	#
	# Instance methods
	#

	### Create a new WorkerDaemon instance.
	def initialize( options )
		@options       = options
		@crew_size     = options.crew_size
		@queue         = LAIKA::GroundControl::Queue.new( options.queue )

		@crew_workers  = []
		@running       = false
		@shutting_down = false

		# Self-pipe for deferred signal-handling (ala djb: http://cr.yp.to/docs/selfpipe.html)
		reader, writer = IO.pipe
		reader.close_on_exec = true
		writer.close_on_exec = true
		@selfpipe      = { reader: reader, writer: writer }

		# Set up a global signal queue
		Thread.main[:signal_queue] = []
	end


	######
	public
	######

	# The Array of PIDs of currently-running workers
	attr_reader :crew_workers

	# The maximum number of children to have running at any given time
	attr_reader :crew_size

	# A self-pipe for deferred signal-handling
	attr_reader :selfpipe

	# The LAIKA::GroundControl::Queue that jobs will be fetched from
	attr_reader :queue

	# The Configurability::Config object for the current configuration.
	attr_reader :config


	### Returns +true+ if the daemon is still running.
	def running?
		return @running
	end


	### Returns +true+ if the daemon is shutting down.
	def shutting_down?
		return @shutting_down
	end


	### Set up the daemon and start running.
	def run
		self.log.info "Starting worker supervisor"

		# Become session leader if we can
		if Process.euid.zero?
			sid = Process.setsid
			self.log.debug "  became session leader of new session: %d" % [ sid ]
		end

		# Set up signal handlers for common signals
		self.set_signal_handlers

		# Listen for new jobs and handle them as they come in
		self.start_handling_jobs

		# Restore the default signal handlers
		self.reset_signal_handlers

		exit
	end


	### The main loop of the daemon -- wait for signals, children dying, or jobs, and
	### take appropriate action.
	def start_handling_jobs
		@running = true

		self.log.debug "Starting supervisor loop..."
		while self.running?
			self.start_missing_children unless self.shutting_down?

			# Wait on the selfpipe for signals
			self.log.debug "  waiting for the selfpipe"
			fds = IO.select( [@selfpipe[:reader]] )
			begin
				rval = @selfpipe[:reader].read_nonblock( 11 )
				self.log.debug "    read from the selfpipe: %p" % [ rval ]
			rescue Errno::EAGAIN, Errno::EINTR => err
				self.log.debug "    %p: %s!" % [ err.class, err.message ]
				# ignore
			end

			# Look for any signals that arrived and handle them
			while sig = Thread.main[:signal_queue].shift
				self.handle_signal( sig )
			end

			self.reap_children
		end
		self.log.info "Supervisor job loop done."

	rescue => err
		self.log.fatal "%p in job-handler loop: %s" % [ err.class, err.message ]
		self.log.debug { '  ' + err.backtrace.join("\n  ") }

	ensure
		self.stop
	end


	### Wake the main thread up through the self-pipe.
	### Note: since this is a signal-handler method, it needs to be re-entrant.
	def wake_up
		@selfpipe[:writer].write_nonblock('.')
	rescue Errno::EAGAIN
		# Ignore.
	rescue Errno::EINTR
		# Repeated signal. :TODO: Does this need a counter?
		retry
	end


	### Shut the daemon down gracefully.
	def stop
		self.ignore_signals
		LAIKA::DB.connection.synchronize {|conn| conn.finish }

		self.log.warn "Halting."
		3.times do |i|
			self.reap_children( *self.crew_workers )
			sleep( 1 )
			self.kill_children
			sleep( 1 )
			break if self.crew_workers.empty?
			sleep( 1 )
		end unless self.crew_workers.empty?

		# Give up on our remaining children.
		Signal.trap( :CHLD, :IGNORE )
		if !self.crew_workers.empty?
			self.log.warn "  %d workers remain: sending KILL" % [ self.crew_workers.length ]
			self.kill_children( :KILL )
		end
	end


	### Reload the configuration.
	def reload_config
		self.log.warn "Reloading config %p" % [ self.config ]
		self.config.reload
	end


	#########
	protected
	#########

	### Set up signal handlers for common signals that will shut down, restart, etc.
	def set_signal_handlers
		self.log.debug "Setting up deferred signal handlers."
		QUEUE_SIGS.each do |sig|
			Signal.trap( sig ) { Thread.main[:signal_queue] << sig; self.wake_up }
		end
		Signal.trap( :CHLD ) { self.wake_up }
	end


	### Set all signal handlers to ignore.
	def ignore_signals
		self.log.debug "Ignoring signals."
		QUEUE_SIGS.each do |sig|
			Signal.trap( sig, :IGNORE )
		end
	end


	### Set the signal handlers back to their defaults.
	def reset_signal_handlers
		self.log.debug "Restoring default signal handlers."
		QUEUE_SIGS.each do |sig|
			Signal.trap( sig, :DEFAULT )
		end
		Signal.trap( :CHLD, :DEFAULT )
	end


	### Handle signals.
	def handle_signal( sig )
		self.log.debug "Handling signal %s" % [ sig ]
		case sig
		when :INT, :TERM
			if @running
				self.log.warn "%s signal: immediate shutdown" % [ sig ]
				@running = false
			else
				self.ignore_signals
				self.log.warn "%s signal: forceful shutdown" % [ sig ]
				self.kill_children( :KILL )
				exit!( 255 )
			end

		when :HUP
			self.log.warn "Hangup signal."
			self.reload_config

		else
			self.log.warn "Unhandled signal %s" % [ sig ]
		end

	end



	### Fill out the work crew with new children if necessary
	def start_missing_children
		missing_count = self.crew_size - self.crew_workers.length
		return unless missing_count > 0

		self.log.debug "Starting %d workers for a crew of %d" % [ missing_count, self.crew_size ]

		missing_count.times do |i|
			pid = self.start_worker
			self.log.debug "  started worker %d" % [ pid ]
			self.crew_workers << pid
		end
	end


	### Kill all current children with the specified +signal+. Returns +true+ if the signal was
	### sent to one or more children.
	def kill_children( signal=:TERM )
		return false if self.crew_workers.empty?

		self.log.info "Sending %s signal to %d workers: %p." % [ signal, self.crew_workers.length, self.crew_workers ]
		Process.kill( signal, *self.crew_workers )

		return true
	rescue Errno::ESRCH
		self.log.debug "Ignoring signals to unreaped children."
	end


	### Start a new GroundControl::Worker and return its PID.
	def start_worker
		return LAIKA::GroundControl::Worker.start( self.queue )
	end


	### Clean up after any children that have died.
	def reap_children( *pids )
		if pids.empty?
			pid, status = Process.waitpid2( -1, Process::WNOHANG )
			while pid
				self.log.debug "Child %d exited: %p." % [ pid, status ]
				self.crew_workers.delete( pid )

				pid, status = Process.waitpid2( -1, Process::WNOHANG )
			end
		else
			pids.each do |pid|
				spid, status = Process.waitpid2( pid )
				if spid
					self.crew_workers.delete( spid )
					self.log.debug "Child %d exited: %p." % [ spid, status ]
				else
					self.log.debug "Child %d no reapy." % [ pid ]
				end
			end
		end
	rescue Errno::ECHILD => err
		self.log.debug "No more children to reap."
	end


end # class LAIKA::GroundControl::WorkerDaemon

Encoding.default_internal = Encoding::UTF_8
LAIKA::GroundControl::WorkerDaemon.run( ARGV )

